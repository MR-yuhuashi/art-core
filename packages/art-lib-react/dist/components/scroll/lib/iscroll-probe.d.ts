import { IScrollOptions } from './typings/iscroll-probe-types';
export default class IScroll {
    constructor(el: string | HTMLElement, options: IScrollOptions);
    wrapper: null | HTMLElement;
    scroller: HTMLElement;
    scrollerStyle: CSSStyleDeclaration;
    options: IScrollOptions;
    translateZ: boolean | string;
    x: number;
    y: number;
    directionX: number;
    directionY: number;
    events: any;
    indicators: any[];
    resizeTimeout: number | undefined;
    isInTransition: boolean | number;
    enabled: boolean;
    initiated: boolean | number;
    moved: boolean;
    distX: number;
    distY: number;
    directionLocked: number | string;
    startTime: number;
    startX: number;
    startY: number;
    absStartX: number;
    absStartY: number;
    pointX: number;
    pointY: number;
    endTime: number;
    hasHorizontalScroll: boolean | undefined;
    hasVerticalScroll: boolean | undefined;
    maxScrollX: number;
    maxScrollY: number;
    currentPage: any;
    wrapperWidth: number;
    wrapperHeight: number;
    scrollerWidth: number;
    scrollerHeight: number;
    wrapperOffset: {
        left: number;
        top: number;
    };
    wheelTimeout: number | undefined;
    pages: any[];
    snapThresholdX: number;
    snapThresholdY: number;
    keyTime: number;
    keyAcceleration: number;
    isAnimating: boolean;
    originalRefresh: any;
    version: string;
    init(): void;
    destroy(): void;
    private transitionEnd;
    private start;
    private move;
    private end;
    private resize;
    resetPosition(time?: any): boolean;
    disable(): void;
    enable(): void;
    refresh(): void;
    on(type: string, fn: any): void;
    off(type: string, fn: any): void;
    execEvent(type: string): void;
    scrollBy(x: number, y: number, time: number, easing: any): void;
    scrollTo(x: any, y: any, time?: any, easing?: any): void;
    scrollToElement(el: any, time: any, offsetX: boolean | number, offsetY: boolean | number, easing: any): void;
    private transitionTime;
    private transitionTimingFunction;
    private translate;
    getComputedPosition(): {
        x: any;
        y: any;
    };
    private initWheel;
    private wheel;
    private initSnap;
    nearestSnap(x: any, y: any): any;
    goToPage: (x: any, y: any, time?: any, easing?: any) => void;
    next(time?: number, easing?: any): void;
    prev(time?: any, easing?: any): void;
    private initKeys;
    private key;
    private animate;
    handleEvent(e: any): void;
    initEvents(remove?: boolean): void;
    initIndicators(): void;
}
